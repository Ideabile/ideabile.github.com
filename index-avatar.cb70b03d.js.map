{"version":3,"sources":["src/index-avatar.tsx"],"names":[],"mappings":";AAAA,IAAM,EAAkB,SAAS,eAAe,WAC1C,EAAU,SAAS,cAAc,kBACjC,EAAO,EAAQ,cAAc,SAC7B,EAAa,EAAQ,cAAc,KAEnC,EAAoB,OAAO,YA2CjC,SAAS,EAAQ,EAAW,EAAY,EAAU,EAAS,QAA1C,IAAA,IAAA,EAAA,QAAW,IAAA,IAAA,EAAA,SAAY,IAAA,IAAA,EAAA,QAAU,IAAA,IAAA,EAAA,SAAS,IAAA,IAAA,EAAA,GACnD,IAEA,EAFgC,KAAjB,EAAQ,GAAgB,GACL,KAAb,EAAO,IAAc,EAAO,IACN,EAE1C,OAAA,EAAS,GAAc,EAAV,EAAc,EAGpC,OAAO,iBAAiB,SAAU,WAChC,OAAA,OAAO,sBAAsB,WACrB,IAAA,EAAkB,EAAQ,wBAAxB,EAAG,EAAA,IAQL,GARa,EAAA,OAKA,OAAO,YAIyC,IAAjE,EAHa,EAAM,EAAQ,aAGX,EAAoB,IAAK,EAAG,EAAG,IAAK,QAAQ,IAE9D,EAAQ,MAAM,OAAS,SAAQ,IAAY,IAAR,EAAc,GAAC,MAClD,EAAQ,MAAM,QAA4B,KAAjB,EAAI,EAAO,IAEpC,EAAK,MAAM,UAAY,eAAc,GAAY,GAAP,GAAS,MACnD,EAAW,MAAM,UAAY,eAAc,GAAY,GAAP,GAAS","file":"index-avatar.cb70b03d.js","sourceRoot":"../exported","sourcesContent":["const HalftoneElement = document.getElementById(\"profile\");\nconst landing = document.querySelector(\".landing--word\");\nconst word = landing.querySelector(\".word\");\nconst definition = landing.querySelector(\"p\");\n\nconst windowInnerHeight = window.innerHeight;\n\n// So we want to detect if a element is in the middle\n// of the screen, with that we want to trigger some parallax\n// so that the scrolling, with some margins can give animation to an element\n// +-------------------+\n// | The page          |\n// +-------------------+\n// |                   |\n// |  The view port    |\n// |                   |\n// | +---------------+ |\n// +-+---------------+-+\n// | |               | |\n// | |  Our element  | |\n// | |               | |\n// | +---------------+ |\n// |                   |\n// +-------------------+\n//\n// The page with might be irrelevant let's explore the options\n// Viewport can be rapresented by\n// top: current top scrolling position\n// bottom: the top + the height of the viewport\n//\n// Element has the following properties\n// top: from getBoundingClientRect().top the current position relative to viewport\n// bottom: from getBoundingClientRect().bottom the current position relative to viewport\n//\n// So lets plot a scenario\n// We have a viewport of { top: 10, bottom: 20 } The height of viewport is 10.\n// Then we have our element at { top: 20, bottom: 30  } The height of the element is same as the viewport.\n// We then want to have a blur of 5px and when the element is at the center we want to have of 0px\n//\n// The first thing is to make sure that the element is in the viewport\n// if (bottom >= top ) is visible from bottom\n// then we now that the blur should be 5px\n// Although when viewport becomes { top: 15, bottom: 25 }\n// and the elements becomes { top: 0, bottom: 10 } the blur should be 0px\n// To invert this calculation we could do\n// (heightOfTheWindow - (topOfTheElement+heightOfTheWindow)) so in our case if is visible 10-10 but if\n// not in window\n\nfunction getStep(input = 0, total = 10, from = 0, to = 10, step = 1) {\n  const percentage = ((total - input) * 100) / total;\n  const inStepPercentage = ((from - to) * 100) / (from - to);\n  const inStep = (percentage / inStepPercentage) * step;\n\n  return inStep < 0 ? inStep * -1 : inStep;\n}\n\nwindow.addEventListener(\"scroll\", () =>\n  window.requestAnimationFrame(() => {\n    const { top, bottom } = landing.getBoundingClientRect();\n\n    const max = 0;\n    const min = 5;\n\n    const halfWindow = window.innerHeight / 2;\n    const middle = top + landing.clientHeight;\n    // ((input - min) * 100) / (max - min)\n    const step =\n      getStep(middle, windowInnerHeight - 100, 0, 5, 0.1).toFixed(3) * 100;\n\n    landing.style.filter = `blur(${1 - step * -1.5 - 4}px)`;\n    landing.style.opacity = (1 - step / 10) * 1.4;\n\n    word.style.transform = `translateX(${20 - step * 10}px)`;\n    definition.style.transform = `translateX(${20 + step * 10}px)`;\n  })\n);\n"]}